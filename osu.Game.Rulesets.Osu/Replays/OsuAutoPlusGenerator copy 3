// Copyright (c) ppy Pty Ltd <contact@ppy.sh>. Licensed under the MIT Licence.
// See the LICENCE file in the repository root for full licence text.

using osuTK;
using osu.Game.Beatmaps;
using osu.Game.Rulesets.Osu.Objects;
using System;
using System.Collections.Generic;
using osu.Framework.Graphics;
using osu.Game.Replays;
using osu.Game.Rulesets.Mods;
using osu.Game.Rulesets.Objects;
using osu.Game.Rulesets.Osu.Beatmaps;
using osu.Game.Rulesets.Osu.Scoring;
using osu.Game.Rulesets.Scoring;
using osu.Framework.Utils;
// using System.Linq;

namespace osu.Game.Rulesets.Osu.Replays
{
    public class OsuAutoPlusGenerator : OsuAutoPlusGeneratorBase
    {
        public new OsuBeatmap Beatmap => (OsuBeatmap)base.Beatmap;

        #region Parameters

        /// <summary>
        /// If delayed movements should be used, causing the cursor to stay on each hitobject for as long as possible.
        /// Mainly for Autopilot.
        /// </summary>
        public bool DelayedMovements; // ModManager.CheckActive(Mods.Relax2);

        #endregion

        #region Constants

        private readonly HitWindows defaultHitWindows;

        /// <summary>
        /// What easing to use when moving between hitobjects
        /// </summary>
        private Easing preferredEasing => DelayedMovements ? Easing.InOutCubic : Easing.None;

        #endregion

        #region Construction / Initialisation

        public OsuAutoPlusGenerator(IBeatmap beatmap, IReadOnlyList<Mod> mods)
            : base(beatmap, mods)
        {
            defaultHitWindows = new OsuHitWindows();
            defaultHitWindows.SetDifficulty(Beatmap.Difficulty.OverallDifficulty);
        }

        #endregion

        #region Generator

        public override Replay Generate()
        {
            if (Beatmap.HitObjects.Count == 0)
                return Replay;

            AddFrameToReplay(new OsuReplayFrame(Beatmap.HitObjects[0].StartTime, new Vector2(Beatmap.HitObjects[0].StackedPosition.X, Beatmap.HitObjects[0].StackedPosition.Y)));

            for (int i = 0; i < Beatmap.HitObjects.Count; i++)
            {
                OsuHitObject h = Beatmap.HitObjects[i];

                addHitObjectReplay(h);
            }

            return Replay;
        }

        private void addHitObjectReplay(OsuHitObject h)
        {
            // Default values for circles/sliders
            Vector2 startPosition = h.StackedPosition;
            float spinnerDirection = -1;

            // The startPosition for the slider should not be its .Position, but the point on the circle whose tangent crosses the current cursor position
            // We also modify spinnerDirection so it spins in the direction it enters the spin circle, to make a smooth transition.
            // TODO: Shouldn't the spinner always spin in the same direction?
            if (h is Spinner)
                calcSpinnerStartPosAndDirection(((OsuReplayFrame)Frames[^1]).Position, out startPosition, out spinnerDirection);


            // Do some nice easing for cursor movements
            // if (Frames.Count > 0)
            // {
            //     moveToHitObject(h, startPosition, Easing.None);
            // }

            // Add frames to click the hitobject
            addHitObjectClickFrames(h, startPosition, spinnerDirection);
        }

        #endregion

        #region Helper subroutines

        private static void calcSpinnerStartPosAndDirection(Vector2 prevPos, out Vector2 startPosition, out float spinnerDirection)
        {
            Vector2 spinCentreOffset = SPINNER_CENTRE - prevPos;
            float distFromCentre = spinCentreOffset.Length;
            float distToTangentPoint = MathF.Sqrt(distFromCentre * distFromCentre - SPIN_RADIUS * SPIN_RADIUS);

            if (distFromCentre > SPIN_RADIUS)
            {
                // Previous cursor position was outside spin circle, set startPosition to the tangent point.

                // Angle between centre offset and tangent point offset.
                float angle = MathF.Asin(SPIN_RADIUS / distFromCentre);

                if (angle > 0)
                {
                    spinnerDirection = -1;
                }
                else
                {
                    spinnerDirection = 1;
                }

                // Rotate by angle so it's parallel to tangent line
                spinCentreOffset.X = spinCentreOffset.X * MathF.Cos(angle) - spinCentreOffset.Y * MathF.Sin(angle);
                spinCentreOffset.Y = spinCentreOffset.X * MathF.Sin(angle) + spinCentreOffset.Y * MathF.Cos(angle);

                // Set length to distToTangentPoint
                spinCentreOffset.Normalize();
                spinCentreOffset *= distToTangentPoint;

                // Move along the tangent line, now startPosition is at the tangent point.
                startPosition = prevPos + spinCentreOffset;
            }
            else if (spinCentreOffset.Length > 0)
            {
                // Previous cursor position was inside spin circle, set startPosition to the nearest point on spin circle.
                startPosition = SPINNER_CENTRE - spinCentreOffset * (SPIN_RADIUS / spinCentreOffset.Length);
                spinnerDirection = 1;
            }
            else
            {
                // Degenerate case where cursor position is exactly at the centre of the spin circle.
                startPosition = SPINNER_CENTRE + new Vector2(0, -SPIN_RADIUS);
                spinnerDirection = 1;
            }
        }

        private void moveToHitObject(OsuHitObject h, Vector2 targetPos, Easing easing)
        {
            OsuReplayFrame lastFrame = (OsuReplayFrame)Frames[^1];

            double timeDifference = ApplyModsToTimeDelta(lastFrame.Time, h.StartTime);

            if (timeDifference > 0)
            {

                Vector2 lastPosition = lastFrame.Position;

                // Perform the rest of the eased movement until the target position is reached.
                for (double time = lastFrame.Time + GetFrameDelay(lastFrame.Time); time < h.StartTime; time += GetFrameDelay(time))
                {
                    Vector2 currentPosition = Interpolation.ValueAt(time, lastPosition, targetPos, lastFrame.Time, h.StartTime, easing);
                    AddFrameToReplay(new OsuReplayFrame((int)time, new Vector2(currentPosition.X, currentPosition.Y)) { Actions = lastFrame.Actions });
                }
            }
        }

        // Add frames to click the hitobject
        private void addHitObjectClickFrames(OsuHitObject h, Vector2 startPosition, float spinnerDirection)
        {
            var action = OsuAction.LeftButton;
            var startFrame = new OsuReplayFrame(h.StartTime, new Vector2(startPosition.X, startPosition.Y), action);
            var startFrameWithoutAction = new OsuKeyUpReplayFrame(h.StartTime, new Vector2(startPosition.X, startPosition.Y));
            var endFrame = new OsuKeyUpReplayFrame(h.GetEndTime(), new Vector2(h.StackedEndPosition.X, h.StackedEndPosition.Y));

            // // 0.05 rad/ms, or ~477 RPM, as per stable.
            // // the redundant conversion from RPM to rad/ms is here for ease of testing custom SPM specs.
            const float spin_rpm = 0.3905175f / (2 * MathF.PI) * 60000;
            float radsPerMillisecond = float.DegreesToRadians(spin_rpm * 360) / 60000;

            AddFrameToReplay(startFrameWithoutAction);
            AddFrameToReplay(startFrame);

            switch (h)
            {
                case Slider slider:
                    foreach (SliderTick tick in slider.Ticks)
                    {
                        AddFrameToReplay(new OsuReplayFrame((int)tick.StartTime, new Vector2(tick.Position.X, tick.Position.Y), OsuAction.LeftButton));
                    }
                    foreach (SliderRepeat repeat in slider.Repeats)
                    {
                        AddFrameToReplay(new OsuReplayFrame((int)repeat.StartTime, new Vector2(repeat.Position.X, repeat.Position.Y), OsuAction.LeftButton));
                    }
                    break;

                case Spinner spinner:
                    Vector2 difference = startPosition - SPINNER_CENTRE;

                    float radius = difference.Length;
                    float angle = radius == 0 ? 0 : MathF.Atan2(difference.Y, difference.X);

                    double t;
                    double previousFrame = h.StartTime;

                    for (double nextFrame = h.StartTime + GetFrameDelay(h.StartTime); nextFrame < spinner.EndTime; nextFrame += GetFrameDelay(nextFrame))
                    {
                        t = ApplyModsToTimeDelta(previousFrame, nextFrame) * spinnerDirection;
                        angle += (float)t * radsPerMillisecond;

                        Vector2 pos = SPINNER_CENTRE + CirclePosition(angle, SPIN_RADIUS);
                        AddFrameToReplay(new OsuReplayFrame((int)nextFrame, new Vector2(pos.X, pos.Y), OsuAction.LeftButton));

                        previousFrame = nextFrame;
                    }

                    t = ApplyModsToTimeDelta(previousFrame, spinner.EndTime) * spinnerDirection;
                    angle += (float)t * radsPerMillisecond;

                    Vector2 endPosition = SPINNER_CENTRE + CirclePosition(angle, SPIN_RADIUS);

                    AddFrameToReplay(new OsuReplayFrame(spinner.EndTime, new Vector2(endPosition.X, endPosition.Y), OsuAction.LeftButton));

                    endFrame.Position = endPosition;
                    break;
            }

            // We only want to let go of our button if we are at the end of the current replay. Otherwise something is still going on after us so we need to keep the button pressed!
            if (Frames[^1].Time <= endFrame.Time)
                AddFrameToReplay(endFrame);
        }

        #endregion

        private class OsuKeyUpReplayFrame : OsuReplayFrame
        {
            public OsuKeyUpReplayFrame(double time, Vector2 position)
                : base(time, position)
            {
            }
        }
    }
}
